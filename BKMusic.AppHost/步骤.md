这是一个非常扎实、循序渐进的后端构建指南。我们将利用 **.NET Aspire** 的强大编排能力，从零搭建这个微服务系统。

我们将按照 **“基础设施 -> 共享内核 -> 核心服务 -> 网关 -> 编排”** 的顺序进行。

---

### 第一阶段：解决方案骨架与基础设施 (Skeleton & Infra)

**目标**：创建 Aspire 解决方案，配置 Docker 容器资源。

1.  **创建项目**
    *   使用 Visual Studio 2022 (17.10+) 或 CLI。
    *   选择模板：`.NET Aspire Application (Starter)`。
    *   命名：`MusicPlatform`。
    *   结构：
        *   `MusicPlatform.AppHost` (编排中心)
        *   `MusicPlatform.ServiceDefaults` (共享的 OpenTelemetry/HealthCheck 配置)

2.  **配置 AppHost (基础设施编排)**
    在 `MusicPlatform.AppHost/Program.cs` 中定义所有依赖的容器。这是 Aspire 最爽的地方——不用手写 `docker-compose.yaml`。

    ```csharp
    var builder = DistributedApplication.CreateBuilder(args);

    // 1. 消息队列 (RabbitMQ) - 用于服务间解耦
    var messaging = builder.AddRabbitMQ("messaging")
                           .WithManagementPlugin(); // 启用管理界面

    // 2. 缓存 (Redis)
    var cache = builder.AddRedis("cache");

    // 3. 数据库 (PostgreSQL)
    var postgres = builder.AddPostgres("postgres")
                          .WithPgAdmin(); // 启用 PgAdmin 管理界面
    
    // 为不同服务划分逻辑库
    var identityDb = postgres.AddDatabase("identity-db");
    var catalogDb = postgres.AddDatabase("catalog-db");
    var mediaDb = postgres.AddDatabase("media-db");

    // 4. 对象存储 (MinIO - 模拟 AWS S3)
    // 需安装 NuGet: CommunityToolkit.Aspire.Hosting.MinIO
    var storage = builder.AddMinIO("storage")
                         .WithDataVolume()
                         .WithLifetime(ContainerLifetime.Persistent); // 重启保留数据
    ```

---

### 第二阶段：共享内核 (Shared Kernel)

**目标**：避免代码重复，统一定义 DTO 和 消息契约。

1.  **新建类库**：`MusicPlatform.Shared`。
2.  **定义消息契约 (Integration Events)**：
    用于 MassTransit 在 RabbitMQ 中传输。
    ```csharp
    // MusicPlatform.Shared/Contracts/MediaEvents.cs
    public record MediaUploadedEvent(Guid SongId, string Bucket, string Key);
    public record MediaProcessedEvent(Guid SongId, string HlsUrl, double Duration, string WaveformData);
    public record SongProcessingFailedEvent(Guid SongId, string Reason);
    ```
3.  **定义通用 DTO**：
    *   `PagedResult<T>`
    *   `ServiceResult` (Result Pattern，用于统一返回成功/失败状态)

---

### 第三阶段：媒体服务 (Media Service) - **最核心难点**

**目标**：处理文件上传、存储，并触发转码任务。

1.  **创建 Web API 项目**：`MusicPlatform.MediaService`。
2.  **安装 Nuget**：
    *   `AWSSDK.S3` (MinIO 兼容 S3 协议)
    *   `MassTransit.RabbitMQ`
3.  **实现功能：生成预签名 URL (Presigned URL)**
    *   **原因**：不要让文件流经过你的 API 服务器，让前端直传 MinIO。
    *   **代码思路**：
    ```csharp
    // Endpoints/StorageEndpoints.cs
    app.MapGet("/api/storage/presign-upload", async (IAmazonS3 s3, string extension) => {
        var key = $"{Guid.NewGuid()}{extension}";
        var request = new GetPreSignedUrlRequest {
            BucketName = "music-raw",
            Key = key,
            Verb = HttpVerb.PUT,
            Expires = DateTime.UtcNow.AddMinutes(10)
        };
        var url = s3.GetPreSignedURL(request);
        return Results.Ok(new { UploadUrl = url, Key = key });
    });
    ```
4.  **实现功能：确认上传**
    *   前端上传成功后，调用此接口。
    *   服务发布消息到 RabbitMQ。
    ```csharp
    app.MapPost("/api/media/confirm", async (IPublishEndpoint publishEndpoint, ConfirmUploadRequest req) => {
        // ... 保存记录到 MediaDB ...
        
        // 发送事件给 Worker
        await publishEndpoint.Publish(new MediaUploadedEvent(req.SongId, "music-raw", req.Key));
        return Results.Ok();
    });
    ```

---

### 第四阶段：转码 Worker (Transcoding Worker)

**目标**：CPU 密集型任务，负责将音频转为 HLS (m3u8)。

1.  **创建 Worker Service 项目**：`MusicPlatform.TranscodingWorker`。
2.  **安装工具**：
    *   在 Dockerfile 中安装 FFmpeg。
    *   Nuget: `MassTransit.RabbitMQ`, `AWSSDK.S3`.
3.  **消费者实现 (Consumer)**：
    ```csharp
    public class TranscodeConsumer : IConsumer<MediaUploadedEvent>
    {
        public async Task Consume(ConsumeContext<MediaUploadedEvent> context)
        {
            var msg = context.Message;
            
            // 1. 从 MinIO 下载原始文件到本地临时目录
            var tempFile = await _storageService.DownloadAsync(msg.Bucket, msg.Key);
            
            // 2. 调用 FFmpeg 进行切片 (Shell Execute)
            // ffmpeg -i input.flac -c:a aac -b:a 128k -hls_time 10 -hls_list_size 0 output.m3u8
            var outputDir = await _ffmpegService.TranscodeToHlsAsync(tempFile);
            
            // 3. 上传所有 .ts 和 .m3u8 文件回 MinIO (music-hls bucket)
            var hlsKey = await _storageService.UploadFolderAsync(outputDir, "music-hls");
            
            // 4. 通知 Catalog 服务
            await _publishEndpoint.Publish(new MediaProcessedEvent(msg.SongId, hlsKey, duration, waveform));
        }
    }
    ```

---

### 第五阶段：目录服务 (Catalog Service)

**目标**：管理元数据，提供给前端展示。

1.  **创建 Web API 项目**：`MusicPlatform.CatalogService`。
2.  **技术栈**：EF Core + PostgreSQL + Redis。
3.  **核心逻辑**：
    *   **CRUD**：`Song`, `Album`, `Artist`。
    *   **监听转码结果**：
        创建 `MediaProcessedConsumer` 监听 RabbitMQ。收到消息后，更新数据库中 `Song` 的状态为 `Ready`，并填入 `HlsUrl` 和 `WaveformData`。
    *   **Redis 缓存**：
        在 `GetSongById` 或 `GetPlaylist` 接口中，使用 **Proxy Pattern** 或 **Decorator** 封装 DB 查询，先查 Redis，无数据查 DB 并回写。

---

### 第六阶段：身份认证服务 (Identity Service)

**目标**：安全入口。

1.  **创建 Web API 项目**：`MusicPlatform.IdentityService`。
2.  **方案**：ASP.NET Core Identity + JWT Bearer。
3.  **关键点**：
    *   配置 `AddIdentity<ApplicationUser, IdentityRole>()`。
    *   实现 `/login`：验证密码 -> 生成 JWT (包含 Sub, Name, Roles Claims) -> 返回 AccessToken + RefreshToken。
    *   实现 `/refresh`：用 RefreshToken 换取新 AccessToken。

---

### 第七阶段：API 网关 (YARP Gateway)

**目标**：统一入口，反向代理。

1.  **创建 Web 项目**：`MusicPlatform.Gateway`。
2.  **安装**：`YARP.ReverseProxy`。
3.  **配置 `appsettings.json`**：
    ```json
    "ReverseProxy": {
      "Routes": {
        "catalog-route": {
          "ClusterId": "catalog-cluster",
          "Match": { "Path": "/api/catalog/{**catch-all}" }
        },
        "media-route": {
          "ClusterId": "media-cluster",
          "Match": { "Path": "/api/media/{**catch-all}" }
        }
      },
      "Clusters": {
        "catalog-cluster": {
          "Destinations": { "destination1": { "Address": "http://catalog-svc" } }
        },
        "media-cluster": {
          "Destinations": { "destination1": { "Address": "http://media-svc" } }
        }
      }
    }
    ```
    *注意：在 Aspire 中，Address 可以通过 Service Discovery 自动注入，YARP 配置可以更简化。*

---

### 第八阶段：最终编排 (Wiring Up)

回到 `MusicPlatform.AppHost` 的 `Program.cs`，将所有服务串联起来。

```csharp
// ... 之前的 infrastructure 定义 ...

// 1. 注册服务
var identitySvc = builder.AddProject<Projects.MusicPlatform_IdentityService>("identity-svc")
                         .WithReference(identityDb);

var mediaSvc = builder.AddProject<Projects.MusicPlatform_MediaService>("media-svc")
                      .WithReference(mediaDb)
                      .WithReference(storage)  // 注入 MinIO 连接信息
                      .WithReference(messaging); // 注入 RabbitMQ

var transcodingWorker = builder.AddProject<Projects.MusicPlatform_TranscodingWorker>("worker")
                               .WithReference(storage)
                               .WithReference(messaging);

var catalogSvc = builder.AddProject<Projects.MusicPlatform_CatalogService>("catalog-svc")
                        .WithReference(catalogDb)
                        .WithReference(cache)
                        .WithReference(messaging);

// 2. 注册网关
builder.AddProject<Projects.MusicPlatform_Gateway>("gateway")
       .WithReference(identitySvc)
       .WithReference(mediaSvc)
       .WithReference(catalogSvc);
       // Aspire 会自动把服务地址注入给 YARP，
       // 你只需要在 Gateway 中通过 ServiceDiscovery 机制解析即可。

builder.Build().Run();
```

---

### 第九阶段：验证与运行

1.  **启动**：F5 运行 `AppHost`。
2.  **Aspire Dashboard**：
    *   你会看到一个超酷的仪表盘。
    *   可以看到 Redis, Postgres, MinIO 容器都起飞了。
    *   可以看到所有 API 服务的状态。
3.  **测试流程**：
    *   使用 Swagger (集成在各微服务中) 调用 Identity 获取 Token。
    *   调用 Media 服务获取上传 URL。
    *   使用 Postman PUT 文件到 MinIO。
    *   调用 Confirm 接口。
    *   观察 Aspire Dashboard 的 **Traces** 视图，看 RabbitMQ 消息是否被 Worker 消费，以及 FFmpeg 是否在后台运行。
    *   查询 Catalog 接口，看歌曲是否出现。

### 重点提示 (Pro Tips)

1.  **FFmpeg 环境**：在开发环境（Windows/Mac），你需要本地安装 FFmpeg 并配置环境变量。在 Docker 部署时，确保 `TranscodingWorker` 的 `Dockerfile` 基于安装了 ffmpeg 的镜像（如 `linuxserver/ffmpeg` 或自己构建）。
2.  **跨域 (CORS)**：网关层和 MinIO 都需要配置 CORS，允许 Flutter 前端访问。
3.  **数据库迁移**：Aspire 启动时，可以使用 Entity Framework Core 的 Migration Bundles 自动应用数据库迁移，或者在 `Program.cs` 启动时加一段 `db.Database.MigrateAsync()`（生产环境慎用，开发环境很方便）。